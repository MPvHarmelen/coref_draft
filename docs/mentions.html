<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5.dev4+g1709915.d20200207" />
<title>multisieve_coreference.mentions API documentation</title>
<meta name="description" content="This module parses the term layer of a KAF/NAF object" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multisieve_coreference.mentions</code></h1>
</header>
<section id="section-intro">
<p>This module parses the term layer of a KAF/NAF object</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L0-L470" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module parses the term layer of a KAF/NAF object
&#34;&#34;&#34;
from __future__ import print_function
import os
import logging

from collections import OrderedDict

from .naf_info import get_pos_of_term
from .constituent import get_named_entities, Constituent
from .offset_info import (
    convert_term_ids_to_offsets,
    get_offset,
    get_offsets_from_span,
)


logger = logging.getLogger(None if __name__ == &#39;__main__&#39; else __name__)


def get_relevant_head_ids(nafobj):
    &#39;&#39;&#39;
    Get a list of term ids that head potential mentions
    :param nafobj: input nafobj
    :return: list of term ids (string)
    &#39;&#39;&#39;

    nominal_pos = [&#39;noun&#39;, &#39;pron&#39;, &#39;name&#39;]
    mention_heads = []
    for term in nafobj.get_terms():
        pos_tag = term.get_pos()
        # check if possessive pronoun
        if pos_tag in nominal_pos or \
           pos_tag == &#39;det&#39; and &#39;VNW(bez&#39; in term.get_morphofeat():
            mention_heads.append(term.get_id())

    return mention_heads


def read_stopword_set(language):
    &#34;&#34;&#34;
    Read a list of stopwords for the given language from the `resources`
    directory that ships with this package.

    :param lang:    language tag in accordance with [RFC5646][]
    :return:        a list of stopwords

    [RFC5646]: https://tools.ietf.org/html/rfc5646#section-2.2
    &#34;&#34;&#34;

    resources = os.path.abspath(os.path.join(
        os.path.dirname(__file__),
        &#34;resources&#34;
    ))

    stopfilename = os.path.join(resources, language, &#39;stopwords.txt&#39;)

    with open(stopfilename, &#39;r&#39;) as stopfile:
        return {line.rstrip() for line in stopfile}


def merge_two_mentions(mention1, mention2):
    &#39;&#39;&#39;
    Merge information from mention 1 into mention 2
    :param mention1:
    :param mention2:
    :return: updated mention
    &#39;&#39;&#39;
    # FIXME; The comments here do not correspond to the code and therefore the
    #        code may be horribly wrong.
    if mention1.head_offset == mention2.head_offset:
        if set(mention1.span) == set(mention2.span):
            # if mention1 does not have entity type, take the one from entity 2
            if mention2.entity_type is None:
                mention2.entity_type = mention1.entity_type
        else:
            # if mention2 has no entity type, it&#39;s span is syntax based
            # (rather than from the NERC module)
            if mention1.entity_type is None:
                mention2.span = mention1.span
    else:
        if mention1.entity_type is None:
            mention2.head_offset = mention1.head_offset
        else:
            mention2.entity_type = mention1.entity_type

    return mention2


def merge_mentions(mentions):
    &#39;&#39;&#39;
    Merge mentions that have an identical span or head.

    Keeps the position of the earliest duplicate mention.

    :param mentions: (possibly ordered) {id: mention} dictionary
    :return:         (possibly ordered) {id: mention} dictionary
    &#39;&#39;&#39;

    final_mentions = type(mentions)()

    # TODO: create merge function and merge identical candidates
    # TODO: This code is O(m**2), but it shouldn&#39;t have to be, because we can
    #       use the ordering of mentions that came from different sources.

    for m, val in mentions.items():
        for prevm, preval in final_mentions.items():
            if val.head_offset == preval.head_offset or \
               set(val.span) == set(preval.span):
                updated_mention = merge_two_mentions(val, preval)
                final_mentions[prevm] = updated_mention
                break
        else:
            final_mentions[m] = val

    return final_mentions


def get_mentions(nafobj, constituency_trees, language):
    &#39;&#39;&#39;
    Function that creates mention objects based on mentions retrieved from NAF
    :param nafobj: input naf
    :return: list of Mention objects
    &#39;&#39;&#39;

    stopwords = read_stopword_set(language)

    mention_heads = get_relevant_head_ids(nafobj)

    logger.debug(&#34;Mention candidate heads: {!r}&#34;.format(mention_heads))

    mention_constituents = [
        Constituent.from_constituency_trees(constituency_trees, head_id=head)
        for head in mention_heads
    ]

    mentions = OrderedDict()
    for constituent in mention_constituents:
        mid = &#39;m&#39; + str(len(mentions))
        mentions[mid] = Mention.from_naf(
            nafobj, stopwords, constituent, id=mid)

    entity_constituents = get_named_entities(nafobj, constituency_trees)
    for entity_type, constituent in entity_constituents:
        mid = &#39;m&#39; + str(len(mentions))
        mentions[mid] = Mention.from_naf(
            nafobj, stopwords, constituent, id=mid,
            entity_type=entity_type)

    if logger.getEffectiveLevel() &lt;= logging.DEBUG:
        from .util import view_mentions
        logger.debug(
            &#34;Mentions before merging: {}&#34;.format(
                view_mentions(nafobj, mentions))
        )

    mentions = merge_mentions(mentions)

    return mentions


class Mention:
    &#39;&#39;&#39;
    This class covers information about mentions that is relevant for
    coreference resolution.

    `span` and other things store _offsets_.

    All attributes must contain hashable values.
    &#39;&#39;&#39;

    # FIXME: begin and end offset are required arguments because the end_offset
    #        is not necessarily the last offset in the span, as the offsets may
    #        be more fine grained than the term level.
    #        Although AFAIK no term will exist with an offset strictly between
    #        span[-1] and end_offset + 1, apparently Antske thought it
    #        worthwhile to write `get_offsets_from_span` to exactly calculate
    #        the offset of the **end** of the last term, instead of just using
    #        the offset of the **start** of the last term.
    #        Someone should try what happens when this last option is used.
    def __init__(
            self,
            id,
            span,
            relaxed_span=(),
            full_head=(),
            head_offset=None,
            begin_offset=None,
            end_offset=None,
            head_pos=None,
            number=None,
            gender=None,
            person=None,
            entity_type=None,
            is_relative_pronoun=False,
            is_reflexive_pronoun=False,
            modifiers=(),
            appositives=(),
            predicatives=(),
            non_stopwords=(),
            main_modifiers=(),
            sentence_number=None,
            ):
        &#39;&#39;&#39;
        Constructor of the mention
        #TODO: revise so that provides information needed for some sieve;
        #STEP 1: sieve 3 needs option to remove post-head modifiers

        :type span:                    (hashable) span, i.e. tuple
        :type relaxed_span:            (hashable) span, i.e. tuple
        :type full_head:               (hashable) span, i.e. tuple
        :type head_offset:             int
        :type begin_offset:            int
        :type end_offset:              int
        :type head_pos:                str
        :type number:                  str
        :type gender:                  str
        :type person:                  str
        :type entity_type:             str
        :type is_relative_pronoun:     bool
        :type is_reflexive_pronoun:    bool
        :type modifiers:               iterable of (hashable) spans
        :type appositives:             iterable of (hashable) spans
        :type predicatives:            iterable of (hashable) spans
        :type non_stopwords:           tuple of offsets
        :type main_modifiers:          iterable of (hashable) spans
        :type sentence_number:         int
        &#39;&#39;&#39;

        self.id = id   # confirmed
        self.span = span

        self.full_head = full_head
        self.relaxed_span = relaxed_span

        self.head_offset = head_offset
        self.begin_offset = begin_offset
        self.end_offset = end_offset

        self.head_pos = head_pos

        self.sentence_number = sentence_number

        self.non_stopwords = non_stopwords

        self.modifiers = modifiers
        self.main_modifiers = main_modifiers
        self.appositives = appositives
        self.predicatives = predicatives

        self.number = number
        self.gender = gender
        self.person = person
        self.entity_type = entity_type

        self.is_relative_pronoun = is_relative_pronoun
        self.is_reflexive_pronoun = is_reflexive_pronoun

    def __repr__(self):
        return self.__class__.__name__ + &#39;(&#39; + \
            &#39;id={self.id!r}, &#39; \
            &#39;span={self.span!r}, &#39; \
            &#39;relaxed_span={self.relaxed_span!r}, &#39; \
            &#39;full_head={self.full_head!r}, &#39; \
            &#39;head_offset={self.head_offset!r}, &#39; \
            &#39;begin_offset={self.begin_offset!r}, &#39; \
            &#39;end_offset={self.end_offset!r}, &#39; \
            &#39;head_pos={self.head_pos!r}, &#39; \
            &#39;number={self.number!r}, &#39; \
            &#39;gender={self.gender!r}, &#39; \
            &#39;person={self.person!r}, &#39; \
            &#39;entity_type={self.entity_type!r}, &#39; \
            &#39;is_relative_pronoun={self.is_relative_pronoun!r}, &#39; \
            &#39;is_reflexive_pronoun={self.is_reflexive_pronoun!r}, &#39; \
            &#39;modifiers={self.modifiers!r}, &#39; \
            &#39;appositives={self.appositives!r}, &#39; \
            &#39;predicatives={self.predicatives!r}, &#39; \
            &#39;non_stopwords={self.non_stopwords!r}, &#39; \
            &#39;main_modifiers={self.main_modifiers!r}, &#39; \
            &#39;sentence_number={self.sentence_number!r}, &#39; \
            &#39;)&#39;.format(self=self)

    def fill_gaps(self, full_content):
        &#34;&#34;&#34;
        Find and fill gaps in the span of this mention.

        :param full_content:  list of things in spans for the whole document
        &#34;&#34;&#34;
        if len(self.span) &gt;= 2:
            start = full_content.index(self.span[0])
            end = full_content.index(self.span[-1], start)
            self.span = tuple(full_content[start:end + 1])

    @classmethod
    def from_naf(cls, nafobj, stopwords, constituent_info, **kwargs):
        &#39;&#39;&#39;
        Create a mention object from naf information

        :param nafobj:              the input naffile
        :param constituent_info:    information about the constituent
        :param head:                the id of the constituent&#39;s head
        :param mid:                 the mid (for creating a unique mention id
        :return:                    a `Mention` object
        &#39;&#39;&#39;

        head_offset = get_offset(nafobj, constituent_info.head_id)

        span_ids = constituent_info.span
        span_offsets = convert_term_ids_to_offsets(nafobj, span_ids)
        begin_offset, end_offset = get_offsets_from_span(nafobj, span_ids)

        # get POS of head
        head_pos = get_pos_of_term(nafobj, constituent_info.head_id)

        # modifiers and appositives:
        modifiers, main_modifiers, appositives = [], [], []

        relaxed_span = list(span_offsets)
        for mod_in_tids in constituent_info.modifiers:
            mod_span = convert_term_ids_to_offsets(nafobj, mod_in_tids)
            modifiers.append(mod_span)
            main_modifiers.append(get_main_modifiers(nafobj, mod_in_tids))
            for offset in mod_span:
                if offset &gt; head_offset and offset in relaxed_span:
                    relaxed_span.remove(offset)

        for app_in_tids in constituent_info.appositives:
            app_span = convert_term_ids_to_offsets(nafobj, app_in_tids)
            appositives.append(app_span)
            for offset in app_span:
                if offset &gt; head_offset and offset in relaxed_span:
                    relaxed_span.remove(offset)

        extra_kwargs = {}
        if head_pos in [&#39;pron&#39;, &#39;noun&#39;, &#39;name&#39;]:
            extra_kwargs[&#39;person&#39;], \
                extra_kwargs[&#39;gender&#39;], \
                extra_kwargs[&#39;number&#39;], \
                extra_kwargs[&#39;is_relative_pronoun&#39;], \
                extra_kwargs[&#39;is_reflexive_pronoun&#39;] = \
                analyze_nominal_information(nafobj, constituent_info.head_id)

        extra_kwargs.update(kwargs)

        mention = cls(
            span=tuple(span_offsets),
            relaxed_span=tuple(relaxed_span),
            full_head=tuple(convert_term_ids_to_offsets(
                nafobj, constituent_info.multiword)),
            head_offset=head_offset,
            begin_offset=begin_offset,
            end_offset=end_offset,
            head_pos=head_pos,
            modifiers=[tuple(m) for m in modifiers],
            appositives=[tuple(a) for a in appositives],
            predicatives=[
                tuple(convert_term_ids_to_offsets(nafobj, pred_ids))
                for pred_ids in constituent_info.predicatives
            ],
            non_stopwords=tuple(
                get_non_stopwords(nafobj, stopwords, span_ids)),
            main_modifiers=[tuple(mods) for mods in main_modifiers],
            sentence_number=get_sentence_number(
                nafobj, constituent_info.head_id),
            **extra_kwargs
        )

        return mention


def get_main_modifiers(nafobj, span):
    &#39;&#39;&#39;
    Function that creates list of all modifiers that are noun or adjective
    (possibly including head itself)

    :param nafobj:  input naf
    :param span:    list of term ids
    :return:        list of offsets of main modifiers
    &#39;&#39;&#39;

    main_mods = []
    for tid in span:
        term = nafobj.get_term(tid)
        if term.get_pos() in [&#39;adj&#39;, &#39;noun&#39;]:
            main_mods.append(tid)

    return convert_term_ids_to_offsets(nafobj, main_mods)


def get_non_stopwords(nafobj, stopwords, span):
    &#39;&#39;&#39;
    Function that verifies which terms in span are not stopwords and adds these
    to non-stopword list

    :param nafobj: input naf (for linguistic information)
    :param span: list of term ids
    :param mention: mention object
    :return:
    &#39;&#39;&#39;
    non_stop_terms = []

    for tid in span:
        my_term = nafobj.get_term(tid)
        if not my_term.get_type() == &#39;closed&#39; and \
           not my_term.get_lemma().lower() in stopwords:
            non_stop_terms.append(tid)

    return convert_term_ids_to_offsets(nafobj, non_stop_terms)


def analyze_nominal_information(nafobj, term_id):

    term = nafobj.get_term(term_id)
    morphofeat = term.get_morphofeat()
    return (
        identify_person(morphofeat),
        identify_gender(morphofeat),
        identify_number(morphofeat, term),
        is_relative_pronoun(morphofeat),
        is_reflexive_pronoun(morphofeat),
    )


def get_sentence_number(nafobj, head):

    myterm = nafobj.get_term(head)
    tokid = myterm.get_span().get_span_ids()[0]
    mytoken = nafobj.get_token(tokid)
    sent_nr = int(mytoken.get_sent())

    return sent_nr


def identify_person(morphofeat):
    if &#39;1&#39; in morphofeat:
        return &#39;1&#39;
    elif &#39;2&#39; in morphofeat:
        return &#39;2&#39;
    elif &#39;3&#39; in morphofeat:
        return &#39;3&#39;


def identify_number(morphofeat, myterm):
    if &#39;ev&#39; in morphofeat:
        return &#39;ev&#39;
    elif &#39;mv&#39; in morphofeat:
        return &#39;mv&#39;
    elif &#39;getal&#39; in morphofeat:
        lemma = myterm.get_lemma()
        if lemma in [&#39;haar&#39;, &#39;zijn&#39;, &#39;mijn&#39;, &#39;jouw&#39;, &#39;je&#39;]:
            return &#39;ev&#39;
        elif lemma in [&#39;ons&#39;, &#39;jullie&#39;, &#39;hun&#39;]:
            return &#39;mv&#39;


def identify_gender(morphofeat):
    if &#39;fem&#39; in morphofeat:
        return &#39;fem&#39;
    elif &#39;masc&#39; in morphofeat:
        return &#39;masc&#39;
    elif &#39;onz,&#39; in morphofeat:      # FIXME: Should this comma be here?
        return &#39;neut&#39;


def is_relative_pronoun(morphofeat):
    return &#39;betr,&#39; in morphofeat    # FIXME: Should this comma be here?


def is_reflexive_pronoun(morphofeat):
    return &#39;refl,&#39; in morphofeat    # FIXME: Should this comma be here?</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="multisieve_coreference.mentions.analyze_nominal_information"><code class="name flex">
<span>def <span class="ident">analyze_nominal_information</span></span>(<span>nafobj, term_id)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L412-L422" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def analyze_nominal_information(nafobj, term_id):

    term = nafobj.get_term(term_id)
    morphofeat = term.get_morphofeat()
    return (
        identify_person(morphofeat),
        identify_gender(morphofeat),
        identify_number(morphofeat, term),
        is_relative_pronoun(morphofeat),
        is_reflexive_pronoun(morphofeat),
    )</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.get_main_modifiers"><code class="name flex">
<span>def <span class="ident">get_main_modifiers</span></span>(<span>nafobj, span)</span>
</code></dt>
<dd>
<section class="desc"><p>Function that creates list of all modifiers that are noun or adjective
(possibly including head itself)</p>
<p>:param nafobj:
input naf
:param span:
list of term ids
:return:
list of offsets of main modifiers</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L372-L388" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_main_modifiers(nafobj, span):
    &#39;&#39;&#39;
    Function that creates list of all modifiers that are noun or adjective
    (possibly including head itself)

    :param nafobj:  input naf
    :param span:    list of term ids
    :return:        list of offsets of main modifiers
    &#39;&#39;&#39;

    main_mods = []
    for tid in span:
        term = nafobj.get_term(tid)
        if term.get_pos() in [&#39;adj&#39;, &#39;noun&#39;]:
            main_mods.append(tid)

    return convert_term_ids_to_offsets(nafobj, main_mods)</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.get_mentions"><code class="name flex">
<span>def <span class="ident">get_mentions</span></span>(<span>nafobj, constituency_trees, language)</span>
</code></dt>
<dd>
<section class="desc"><p>Function that creates mention objects based on mentions retrieved from NAF
:param nafobj: input naf
:return: list of Mention objects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L120-L160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_mentions(nafobj, constituency_trees, language):
    &#39;&#39;&#39;
    Function that creates mention objects based on mentions retrieved from NAF
    :param nafobj: input naf
    :return: list of Mention objects
    &#39;&#39;&#39;

    stopwords = read_stopword_set(language)

    mention_heads = get_relevant_head_ids(nafobj)

    logger.debug(&#34;Mention candidate heads: {!r}&#34;.format(mention_heads))

    mention_constituents = [
        Constituent.from_constituency_trees(constituency_trees, head_id=head)
        for head in mention_heads
    ]

    mentions = OrderedDict()
    for constituent in mention_constituents:
        mid = &#39;m&#39; + str(len(mentions))
        mentions[mid] = Mention.from_naf(
            nafobj, stopwords, constituent, id=mid)

    entity_constituents = get_named_entities(nafobj, constituency_trees)
    for entity_type, constituent in entity_constituents:
        mid = &#39;m&#39; + str(len(mentions))
        mentions[mid] = Mention.from_naf(
            nafobj, stopwords, constituent, id=mid,
            entity_type=entity_type)

    if logger.getEffectiveLevel() &lt;= logging.DEBUG:
        from .util import view_mentions
        logger.debug(
            &#34;Mentions before merging: {}&#34;.format(
                view_mentions(nafobj, mentions))
        )

    mentions = merge_mentions(mentions)

    return mentions</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.get_non_stopwords"><code class="name flex">
<span>def <span class="ident">get_non_stopwords</span></span>(<span>nafobj, stopwords, span)</span>
</code></dt>
<dd>
<section class="desc"><p>Function that verifies which terms in span are not stopwords and adds these
to non-stopword list</p>
<p>:param nafobj: input naf (for linguistic information)
:param span: list of term ids
:param mention: mention object
:return:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L391-L409" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_non_stopwords(nafobj, stopwords, span):
    &#39;&#39;&#39;
    Function that verifies which terms in span are not stopwords and adds these
    to non-stopword list

    :param nafobj: input naf (for linguistic information)
    :param span: list of term ids
    :param mention: mention object
    :return:
    &#39;&#39;&#39;
    non_stop_terms = []

    for tid in span:
        my_term = nafobj.get_term(tid)
        if not my_term.get_type() == &#39;closed&#39; and \
           not my_term.get_lemma().lower() in stopwords:
            non_stop_terms.append(tid)

    return convert_term_ids_to_offsets(nafobj, non_stop_terms)</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.get_relevant_head_ids"><code class="name flex">
<span>def <span class="ident">get_relevant_head_ids</span></span>(<span>nafobj)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a list of term ids that head potential mentions
:param nafobj: input nafobj
:return: list of term ids (string)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L22-L38" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_relevant_head_ids(nafobj):
    &#39;&#39;&#39;
    Get a list of term ids that head potential mentions
    :param nafobj: input nafobj
    :return: list of term ids (string)
    &#39;&#39;&#39;

    nominal_pos = [&#39;noun&#39;, &#39;pron&#39;, &#39;name&#39;]
    mention_heads = []
    for term in nafobj.get_terms():
        pos_tag = term.get_pos()
        # check if possessive pronoun
        if pos_tag in nominal_pos or \
           pos_tag == &#39;det&#39; and &#39;VNW(bez&#39; in term.get_morphofeat():
            mention_heads.append(term.get_id())

    return mention_heads</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.get_sentence_number"><code class="name flex">
<span>def <span class="ident">get_sentence_number</span></span>(<span>nafobj, head)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L425-L432" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_sentence_number(nafobj, head):

    myterm = nafobj.get_term(head)
    tokid = myterm.get_span().get_span_ids()[0]
    mytoken = nafobj.get_token(tokid)
    sent_nr = int(mytoken.get_sent())

    return sent_nr</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.identify_gender"><code class="name flex">
<span>def <span class="ident">identify_gender</span></span>(<span>morphofeat)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L457-L463" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def identify_gender(morphofeat):
    if &#39;fem&#39; in morphofeat:
        return &#39;fem&#39;
    elif &#39;masc&#39; in morphofeat:
        return &#39;masc&#39;
    elif &#39;onz,&#39; in morphofeat:      # FIXME: Should this comma be here?
        return &#39;neut&#39;</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.identify_number"><code class="name flex">
<span>def <span class="ident">identify_number</span></span>(<span>morphofeat, myterm)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L444-L454" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def identify_number(morphofeat, myterm):
    if &#39;ev&#39; in morphofeat:
        return &#39;ev&#39;
    elif &#39;mv&#39; in morphofeat:
        return &#39;mv&#39;
    elif &#39;getal&#39; in morphofeat:
        lemma = myterm.get_lemma()
        if lemma in [&#39;haar&#39;, &#39;zijn&#39;, &#39;mijn&#39;, &#39;jouw&#39;, &#39;je&#39;]:
            return &#39;ev&#39;
        elif lemma in [&#39;ons&#39;, &#39;jullie&#39;, &#39;hun&#39;]:
            return &#39;mv&#39;</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.identify_person"><code class="name flex">
<span>def <span class="ident">identify_person</span></span>(<span>morphofeat)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L435-L441" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def identify_person(morphofeat):
    if &#39;1&#39; in morphofeat:
        return &#39;1&#39;
    elif &#39;2&#39; in morphofeat:
        return &#39;2&#39;
    elif &#39;3&#39; in morphofeat:
        return &#39;3&#39;</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.is_reflexive_pronoun"><code class="name flex">
<span>def <span class="ident">is_reflexive_pronoun</span></span>(<span>morphofeat)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L470-L471" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_reflexive_pronoun(morphofeat):
    return &#39;refl,&#39; in morphofeat    # FIXME: Should this comma be here?</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.is_relative_pronoun"><code class="name flex">
<span>def <span class="ident">is_relative_pronoun</span></span>(<span>morphofeat)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L466-L467" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_relative_pronoun(morphofeat):
    return &#39;betr,&#39; in morphofeat    # FIXME: Should this comma be here?</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.merge_mentions"><code class="name flex">
<span>def <span class="ident">merge_mentions</span></span>(<span>mentions)</span>
</code></dt>
<dd>
<section class="desc"><p>Merge mentions that have an identical span or head.</p>
<p>Keeps the position of the earliest duplicate mention.</p>
<p>:param mentions: (possibly ordered) {id: mention} dictionary
:return:
(possibly ordered) {id: mention} dictionary</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L91-L117" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def merge_mentions(mentions):
    &#39;&#39;&#39;
    Merge mentions that have an identical span or head.

    Keeps the position of the earliest duplicate mention.

    :param mentions: (possibly ordered) {id: mention} dictionary
    :return:         (possibly ordered) {id: mention} dictionary
    &#39;&#39;&#39;

    final_mentions = type(mentions)()

    # TODO: create merge function and merge identical candidates
    # TODO: This code is O(m**2), but it shouldn&#39;t have to be, because we can
    #       use the ordering of mentions that came from different sources.

    for m, val in mentions.items():
        for prevm, preval in final_mentions.items():
            if val.head_offset == preval.head_offset or \
               set(val.span) == set(preval.span):
                updated_mention = merge_two_mentions(val, preval)
                final_mentions[prevm] = updated_mention
                break
        else:
            final_mentions[m] = val

    return final_mentions</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.merge_two_mentions"><code class="name flex">
<span>def <span class="ident">merge_two_mentions</span></span>(<span>mention1, mention2)</span>
</code></dt>
<dd>
<section class="desc"><p>Merge information from mention 1 into mention 2
:param mention1:
:param mention2:
:return: updated mention</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L63-L88" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def merge_two_mentions(mention1, mention2):
    &#39;&#39;&#39;
    Merge information from mention 1 into mention 2
    :param mention1:
    :param mention2:
    :return: updated mention
    &#39;&#39;&#39;
    # FIXME; The comments here do not correspond to the code and therefore the
    #        code may be horribly wrong.
    if mention1.head_offset == mention2.head_offset:
        if set(mention1.span) == set(mention2.span):
            # if mention1 does not have entity type, take the one from entity 2
            if mention2.entity_type is None:
                mention2.entity_type = mention1.entity_type
        else:
            # if mention2 has no entity type, it&#39;s span is syntax based
            # (rather than from the NERC module)
            if mention1.entity_type is None:
                mention2.span = mention1.span
    else:
        if mention1.entity_type is None:
            mention2.head_offset = mention1.head_offset
        else:
            mention2.entity_type = mention1.entity_type

    return mention2</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.mentions.read_stopword_set"><code class="name flex">
<span>def <span class="ident">read_stopword_set</span></span>(<span>language)</span>
</code></dt>
<dd>
<section class="desc"><p>Read a list of stopwords for the given language from the <code>resources</code>
directory that ships with this package.</p>
<p>:param lang:
language tag in accordance with <a href="https://tools.ietf.org/html/rfc5646#section-2.2">RFC5646</a>
:return:
a list of stopwords</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L41-L60" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_stopword_set(language):
    &#34;&#34;&#34;
    Read a list of stopwords for the given language from the `resources`
    directory that ships with this package.

    :param lang:    language tag in accordance with [RFC5646][]
    :return:        a list of stopwords

    [RFC5646]: https://tools.ietf.org/html/rfc5646#section-2.2
    &#34;&#34;&#34;

    resources = os.path.abspath(os.path.join(
        os.path.dirname(__file__),
        &#34;resources&#34;
    ))

    stopfilename = os.path.join(resources, language, &#39;stopwords.txt&#39;)

    with open(stopfilename, &#39;r&#39;) as stopfile:
        return {line.rstrip() for line in stopfile}</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multisieve_coreference.mentions.Mention"><code class="flex name class">
<span>class <span class="ident">Mention</span></span>
<span>(</span><span>id, span, relaxed_span=(), full_head=(), head_offset=None, begin_offset=None, end_offset=None, head_pos=None, number=None, gender=None, person=None, entity_type=None, is_relative_pronoun=False, is_reflexive_pronoun=False, modifiers=(), appositives=(), predicatives=(), non_stopwords=(), main_modifiers=(), sentence_number=None)</span>
</code></dt>
<dd>
<section class="desc"><p>This class covers information about mentions that is relevant for
coreference resolution.</p>
<p><code>span</code> and other things store <em>offsets</em>.</p>
<p>All attributes must contain hashable values.</p>
<p>Constructor of the mention</p>
<h1 id="todo-revise-so-that-provides-information-needed-for-some-sieve">TODO: revise so that provides information needed for some sieve;</h1>
<h1 id="step-1-sieve-3-needs-option-to-remove-post-head-modifiers">STEP 1: sieve 3 needs option to remove post-head modifiers</h1>
<p>:type span:
(hashable) span, i.e. tuple
:type relaxed_span:
(hashable) span, i.e. tuple
:type full_head:
(hashable) span, i.e. tuple
:type head_offset:
int
:type begin_offset:
int
:type end_offset:
int
:type head_pos:
str
:type number:
str
:type gender:
str
:type person:
str
:type entity_type:
str
:type is_relative_pronoun:
bool
:type is_reflexive_pronoun:
bool
:type modifiers:
iterable of (hashable) spans
:type appositives:
iterable of (hashable) spans
:type predicatives:
iterable of (hashable) spans
:type non_stopwords:
tuple of offsets
:type main_modifiers:
iterable of (hashable) spans
:type sentence_number:
int</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L163-L369" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Mention:
    &#39;&#39;&#39;
    This class covers information about mentions that is relevant for
    coreference resolution.

    `span` and other things store _offsets_.

    All attributes must contain hashable values.
    &#39;&#39;&#39;

    # FIXME: begin and end offset are required arguments because the end_offset
    #        is not necessarily the last offset in the span, as the offsets may
    #        be more fine grained than the term level.
    #        Although AFAIK no term will exist with an offset strictly between
    #        span[-1] and end_offset + 1, apparently Antske thought it
    #        worthwhile to write `get_offsets_from_span` to exactly calculate
    #        the offset of the **end** of the last term, instead of just using
    #        the offset of the **start** of the last term.
    #        Someone should try what happens when this last option is used.
    def __init__(
            self,
            id,
            span,
            relaxed_span=(),
            full_head=(),
            head_offset=None,
            begin_offset=None,
            end_offset=None,
            head_pos=None,
            number=None,
            gender=None,
            person=None,
            entity_type=None,
            is_relative_pronoun=False,
            is_reflexive_pronoun=False,
            modifiers=(),
            appositives=(),
            predicatives=(),
            non_stopwords=(),
            main_modifiers=(),
            sentence_number=None,
            ):
        &#39;&#39;&#39;
        Constructor of the mention
        #TODO: revise so that provides information needed for some sieve;
        #STEP 1: sieve 3 needs option to remove post-head modifiers

        :type span:                    (hashable) span, i.e. tuple
        :type relaxed_span:            (hashable) span, i.e. tuple
        :type full_head:               (hashable) span, i.e. tuple
        :type head_offset:             int
        :type begin_offset:            int
        :type end_offset:              int
        :type head_pos:                str
        :type number:                  str
        :type gender:                  str
        :type person:                  str
        :type entity_type:             str
        :type is_relative_pronoun:     bool
        :type is_reflexive_pronoun:    bool
        :type modifiers:               iterable of (hashable) spans
        :type appositives:             iterable of (hashable) spans
        :type predicatives:            iterable of (hashable) spans
        :type non_stopwords:           tuple of offsets
        :type main_modifiers:          iterable of (hashable) spans
        :type sentence_number:         int
        &#39;&#39;&#39;

        self.id = id   # confirmed
        self.span = span

        self.full_head = full_head
        self.relaxed_span = relaxed_span

        self.head_offset = head_offset
        self.begin_offset = begin_offset
        self.end_offset = end_offset

        self.head_pos = head_pos

        self.sentence_number = sentence_number

        self.non_stopwords = non_stopwords

        self.modifiers = modifiers
        self.main_modifiers = main_modifiers
        self.appositives = appositives
        self.predicatives = predicatives

        self.number = number
        self.gender = gender
        self.person = person
        self.entity_type = entity_type

        self.is_relative_pronoun = is_relative_pronoun
        self.is_reflexive_pronoun = is_reflexive_pronoun

    def __repr__(self):
        return self.__class__.__name__ + &#39;(&#39; + \
            &#39;id={self.id!r}, &#39; \
            &#39;span={self.span!r}, &#39; \
            &#39;relaxed_span={self.relaxed_span!r}, &#39; \
            &#39;full_head={self.full_head!r}, &#39; \
            &#39;head_offset={self.head_offset!r}, &#39; \
            &#39;begin_offset={self.begin_offset!r}, &#39; \
            &#39;end_offset={self.end_offset!r}, &#39; \
            &#39;head_pos={self.head_pos!r}, &#39; \
            &#39;number={self.number!r}, &#39; \
            &#39;gender={self.gender!r}, &#39; \
            &#39;person={self.person!r}, &#39; \
            &#39;entity_type={self.entity_type!r}, &#39; \
            &#39;is_relative_pronoun={self.is_relative_pronoun!r}, &#39; \
            &#39;is_reflexive_pronoun={self.is_reflexive_pronoun!r}, &#39; \
            &#39;modifiers={self.modifiers!r}, &#39; \
            &#39;appositives={self.appositives!r}, &#39; \
            &#39;predicatives={self.predicatives!r}, &#39; \
            &#39;non_stopwords={self.non_stopwords!r}, &#39; \
            &#39;main_modifiers={self.main_modifiers!r}, &#39; \
            &#39;sentence_number={self.sentence_number!r}, &#39; \
            &#39;)&#39;.format(self=self)

    def fill_gaps(self, full_content):
        &#34;&#34;&#34;
        Find and fill gaps in the span of this mention.

        :param full_content:  list of things in spans for the whole document
        &#34;&#34;&#34;
        if len(self.span) &gt;= 2:
            start = full_content.index(self.span[0])
            end = full_content.index(self.span[-1], start)
            self.span = tuple(full_content[start:end + 1])

    @classmethod
    def from_naf(cls, nafobj, stopwords, constituent_info, **kwargs):
        &#39;&#39;&#39;
        Create a mention object from naf information

        :param nafobj:              the input naffile
        :param constituent_info:    information about the constituent
        :param head:                the id of the constituent&#39;s head
        :param mid:                 the mid (for creating a unique mention id
        :return:                    a `Mention` object
        &#39;&#39;&#39;

        head_offset = get_offset(nafobj, constituent_info.head_id)

        span_ids = constituent_info.span
        span_offsets = convert_term_ids_to_offsets(nafobj, span_ids)
        begin_offset, end_offset = get_offsets_from_span(nafobj, span_ids)

        # get POS of head
        head_pos = get_pos_of_term(nafobj, constituent_info.head_id)

        # modifiers and appositives:
        modifiers, main_modifiers, appositives = [], [], []

        relaxed_span = list(span_offsets)
        for mod_in_tids in constituent_info.modifiers:
            mod_span = convert_term_ids_to_offsets(nafobj, mod_in_tids)
            modifiers.append(mod_span)
            main_modifiers.append(get_main_modifiers(nafobj, mod_in_tids))
            for offset in mod_span:
                if offset &gt; head_offset and offset in relaxed_span:
                    relaxed_span.remove(offset)

        for app_in_tids in constituent_info.appositives:
            app_span = convert_term_ids_to_offsets(nafobj, app_in_tids)
            appositives.append(app_span)
            for offset in app_span:
                if offset &gt; head_offset and offset in relaxed_span:
                    relaxed_span.remove(offset)

        extra_kwargs = {}
        if head_pos in [&#39;pron&#39;, &#39;noun&#39;, &#39;name&#39;]:
            extra_kwargs[&#39;person&#39;], \
                extra_kwargs[&#39;gender&#39;], \
                extra_kwargs[&#39;number&#39;], \
                extra_kwargs[&#39;is_relative_pronoun&#39;], \
                extra_kwargs[&#39;is_reflexive_pronoun&#39;] = \
                analyze_nominal_information(nafobj, constituent_info.head_id)

        extra_kwargs.update(kwargs)

        mention = cls(
            span=tuple(span_offsets),
            relaxed_span=tuple(relaxed_span),
            full_head=tuple(convert_term_ids_to_offsets(
                nafobj, constituent_info.multiword)),
            head_offset=head_offset,
            begin_offset=begin_offset,
            end_offset=end_offset,
            head_pos=head_pos,
            modifiers=[tuple(m) for m in modifiers],
            appositives=[tuple(a) for a in appositives],
            predicatives=[
                tuple(convert_term_ids_to_offsets(nafobj, pred_ids))
                for pred_ids in constituent_info.predicatives
            ],
            non_stopwords=tuple(
                get_non_stopwords(nafobj, stopwords, span_ids)),
            main_modifiers=[tuple(mods) for mods in main_modifiers],
            sentence_number=get_sentence_number(
                nafobj, constituent_info.head_id),
            **extra_kwargs
        )

        return mention</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="multisieve_coreference.mentions.Mention.from_naf"><code class="name flex">
<span>def <span class="ident">from_naf</span></span>(<span>nafobj, stopwords, constituent_info, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a mention object from naf information</p>
<p>:param nafobj:
the input naffile
:param constituent_info:
information about the constituent
:param head:
the id of the constituent's head
:param mid:
the mid (for creating a unique mention id
:return:
a <a title="multisieve_coreference.mentions.Mention" href="#multisieve_coreference.mentions.Mention"><code>Mention</code></a> object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L295-L369" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def from_naf(cls, nafobj, stopwords, constituent_info, **kwargs):
    &#39;&#39;&#39;
    Create a mention object from naf information

    :param nafobj:              the input naffile
    :param constituent_info:    information about the constituent
    :param head:                the id of the constituent&#39;s head
    :param mid:                 the mid (for creating a unique mention id
    :return:                    a `Mention` object
    &#39;&#39;&#39;

    head_offset = get_offset(nafobj, constituent_info.head_id)

    span_ids = constituent_info.span
    span_offsets = convert_term_ids_to_offsets(nafobj, span_ids)
    begin_offset, end_offset = get_offsets_from_span(nafobj, span_ids)

    # get POS of head
    head_pos = get_pos_of_term(nafobj, constituent_info.head_id)

    # modifiers and appositives:
    modifiers, main_modifiers, appositives = [], [], []

    relaxed_span = list(span_offsets)
    for mod_in_tids in constituent_info.modifiers:
        mod_span = convert_term_ids_to_offsets(nafobj, mod_in_tids)
        modifiers.append(mod_span)
        main_modifiers.append(get_main_modifiers(nafobj, mod_in_tids))
        for offset in mod_span:
            if offset &gt; head_offset and offset in relaxed_span:
                relaxed_span.remove(offset)

    for app_in_tids in constituent_info.appositives:
        app_span = convert_term_ids_to_offsets(nafobj, app_in_tids)
        appositives.append(app_span)
        for offset in app_span:
            if offset &gt; head_offset and offset in relaxed_span:
                relaxed_span.remove(offset)

    extra_kwargs = {}
    if head_pos in [&#39;pron&#39;, &#39;noun&#39;, &#39;name&#39;]:
        extra_kwargs[&#39;person&#39;], \
            extra_kwargs[&#39;gender&#39;], \
            extra_kwargs[&#39;number&#39;], \
            extra_kwargs[&#39;is_relative_pronoun&#39;], \
            extra_kwargs[&#39;is_reflexive_pronoun&#39;] = \
            analyze_nominal_information(nafobj, constituent_info.head_id)

    extra_kwargs.update(kwargs)

    mention = cls(
        span=tuple(span_offsets),
        relaxed_span=tuple(relaxed_span),
        full_head=tuple(convert_term_ids_to_offsets(
            nafobj, constituent_info.multiword)),
        head_offset=head_offset,
        begin_offset=begin_offset,
        end_offset=end_offset,
        head_pos=head_pos,
        modifiers=[tuple(m) for m in modifiers],
        appositives=[tuple(a) for a in appositives],
        predicatives=[
            tuple(convert_term_ids_to_offsets(nafobj, pred_ids))
            for pred_ids in constituent_info.predicatives
        ],
        non_stopwords=tuple(
            get_non_stopwords(nafobj, stopwords, span_ids)),
        main_modifiers=[tuple(mods) for mods in main_modifiers],
        sentence_number=get_sentence_number(
            nafobj, constituent_info.head_id),
        **extra_kwargs
    )

    return mention</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multisieve_coreference.mentions.Mention.fill_gaps"><code class="name flex">
<span>def <span class="ident">fill_gaps</span></span>(<span>self, full_content)</span>
</code></dt>
<dd>
<section class="desc"><p>Find and fill gaps in the span of this mention.</p>
<p>:param full_content:
list of things in spans for the whole document</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/mentions.py#L284-L293" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fill_gaps(self, full_content):
    &#34;&#34;&#34;
    Find and fill gaps in the span of this mention.

    :param full_content:  list of things in spans for the whole document
    &#34;&#34;&#34;
    if len(self.span) &gt;= 2:
        start = full_content.index(self.span[0])
        end = full_content.index(self.span[-1], start)
        self.span = tuple(full_content[start:end + 1])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multisieve_coreference" href="index.html">multisieve_coreference</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="multisieve_coreference.mentions.analyze_nominal_information" href="#multisieve_coreference.mentions.analyze_nominal_information">analyze_nominal_information</a></code></li>
<li><code><a title="multisieve_coreference.mentions.get_main_modifiers" href="#multisieve_coreference.mentions.get_main_modifiers">get_main_modifiers</a></code></li>
<li><code><a title="multisieve_coreference.mentions.get_mentions" href="#multisieve_coreference.mentions.get_mentions">get_mentions</a></code></li>
<li><code><a title="multisieve_coreference.mentions.get_non_stopwords" href="#multisieve_coreference.mentions.get_non_stopwords">get_non_stopwords</a></code></li>
<li><code><a title="multisieve_coreference.mentions.get_relevant_head_ids" href="#multisieve_coreference.mentions.get_relevant_head_ids">get_relevant_head_ids</a></code></li>
<li><code><a title="multisieve_coreference.mentions.get_sentence_number" href="#multisieve_coreference.mentions.get_sentence_number">get_sentence_number</a></code></li>
<li><code><a title="multisieve_coreference.mentions.identify_gender" href="#multisieve_coreference.mentions.identify_gender">identify_gender</a></code></li>
<li><code><a title="multisieve_coreference.mentions.identify_number" href="#multisieve_coreference.mentions.identify_number">identify_number</a></code></li>
<li><code><a title="multisieve_coreference.mentions.identify_person" href="#multisieve_coreference.mentions.identify_person">identify_person</a></code></li>
<li><code><a title="multisieve_coreference.mentions.is_reflexive_pronoun" href="#multisieve_coreference.mentions.is_reflexive_pronoun">is_reflexive_pronoun</a></code></li>
<li><code><a title="multisieve_coreference.mentions.is_relative_pronoun" href="#multisieve_coreference.mentions.is_relative_pronoun">is_relative_pronoun</a></code></li>
<li><code><a title="multisieve_coreference.mentions.merge_mentions" href="#multisieve_coreference.mentions.merge_mentions">merge_mentions</a></code></li>
<li><code><a title="multisieve_coreference.mentions.merge_two_mentions" href="#multisieve_coreference.mentions.merge_two_mentions">merge_two_mentions</a></code></li>
<li><code><a title="multisieve_coreference.mentions.read_stopword_set" href="#multisieve_coreference.mentions.read_stopword_set">read_stopword_set</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multisieve_coreference.mentions.Mention" href="#multisieve_coreference.mentions.Mention">Mention</a></code></h4>
<ul class="">
<li><code><a title="multisieve_coreference.mentions.Mention.fill_gaps" href="#multisieve_coreference.mentions.Mention.fill_gaps">fill_gaps</a></code></li>
<li><code><a title="multisieve_coreference.mentions.Mention.from_naf" href="#multisieve_coreference.mentions.Mention.from_naf">from_naf</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5.dev4+g1709915.d20200207</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>