<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5.dev4+g1709915.d20200207" />
<title>multisieve_coreference.constituency_trees API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multisieve_coreference.constituency_trees</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L0-L378" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import logging

from collections import defaultdict

logger = logging.getLogger(None if __name__ == &#39;__main__&#39; else __name__)


class ConstituencyTrees:
    &#34;&#34;&#34;
    A (bit of a messy) collection of several constituency trees,
    together with some convenience functions.

    Because NAF-files don&#39;t specify what edges are part of which tree,
    this class doesn&#39;t know either.

    This class can&#39;t handle it if you change `head2deps` and/or `dep2heads`
    after initialisation.

    !! NB !! Alpino does **not** output strict trees. This means we cannot even
             assume we&#39;re working with a graph that is a set of disjoint trees,
             but have to accept the fact we have to be able to handle every
             kind of graph.
    &#34;&#34;&#34;

    def __init__(self, head2deps):
        &#34;&#34;&#34;
        Initialise `ConstituencyTrees`
        &#34;&#34;&#34;
        self.head2deps = head2deps

        # Create the reverse too
        self.dep2heads = self.reverse_headdep_dict(head2deps)

        logger.debug(&#34;head2deps: {}&#34;.format(self.head2deps))
        logger.debug(&#34;dep2heads: {}&#34;.format(self.dep2heads))
        self._head2constituent = {}

    def __repr__(self):
        return self.__class__.__name__ + &#39;({!r})&#39;.format(self.head2deps)

    def __eq__(self, other):
        if isinstance(other, type(self)):
            return self.head2deps == other.head2deps
        return NotImplemented

    @classmethod
    def from_naf(cls, nafobj, term_filter=None,
                 filter_direct_self_reference=False):
        &#34;&#34;&#34;
        Initialise this ConstituencyTrees from a NAF object

        Only keep terms where `term_filter(naf, term)` evaluates True.


        :param nafobj:          NAF object from input
        :type  nafobj:          KafNafParser

        :param term_filter:     filter for terms
        :type  term_filter:     Callable[[KafNafParser, str], bool]

        :param filter_direct_self_reference:
            whether to call `self.filter_direct_self_reference` on the result
        &#34;&#34;&#34;
        if term_filter is None:
            def term_filter(naf, t):
                return True

        filtered = cls.filter_headdep_dict(
            cls.create_headdep_dict(nafobj),
            lambda t: term_filter(nafobj, t)
        )
        if filter_direct_self_reference:
            filtered = cls.filter_direct_self_reference(filtered)
        return cls(filtered)

    @staticmethod
    def reverse_headdep_dict(head2deps):
        &#34;&#34;&#34;
        Create dep2heads from head2deps (or visa versa?)
        &#34;&#34;&#34;
        dep2heads = {}
        for headID, deps in head2deps.items():
            for toID, relation in deps:
                dep2heads.setdefault(toID, set()).add((headID, relation))
        return dep2heads

    def get_roots(self, ignore_non_trees=False, try_fixing=False):
        &#34;&#34;&#34;
        Get the roots of this collection of &#34;trees&#34;.

        The roots are all heads that aren&#39;t a dependent.

        Because of circular references, this could be non-existent for some of
        the &#34;trees&#34;. In those cases an error will be raised, except if
        `ignore_non_trees` is falsey: then the check is skipped entirely.

        if `try_fixing` is truthy, an ugly hack will try to find the &#34;real&#34;
        roots by finding things that point using &#39;-- / --&#39;: the relation Alpino
        uses to point to punctuation.
        &#34;&#34;&#34;
        roots = set(self.head2deps) - set(self.dep2heads)

        # Check for missing roots
        # If none are missing, removing all heads that are dependent of it
        # (including themselves) should leave nothing.
        if not ignore_non_trees or try_fixing:
            something_left = set(self.head2deps).difference(
                *map(self.get_constituent, roots)
            )
            if something_left:
                problems = {key: self.head2deps[key] for key in something_left}
                if not try_fixing:  # This now implies `not ignore_non_trees`
                    raise ValueError(
                        &#34;Circular reference detected.&#34;
                        &#34; Missing graph: {}&#34;.format(problems)
                    )

                # Try finding roots by finding the things that point using
                # &#39;-- / --&#39;
                punct_rel = &#39;-- / --&#39;
                additional_roots = {
                    tID
                    for tID in something_left
                    if punct_rel in map(lambda p: p[1], self.head2deps[tID])
                }

                # Verify we don&#39;t have too many
                for r in additional_roots:
                    # If some additional root dominates some other additional
                    # root, this is a problem, as every connected graph can
                    # have at most one root.
                    dominated = self.get_constituent(r) &amp; additional_roots
                    dominated.remove(r)  # we know `r` must be in there
                    if dominated:
                        raise ValueError(
                            &#34;Found too many additional roots.&#34;
                            &#34; {} dominates {} in {}&#34;.format(
                                r,
                                dominated,
                                problems
                            )
                        )

                roots |= additional_roots

                # Verify we have everything
                if not ignore_non_trees:
                    something_left = set(self.head2deps).difference(
                        *map(self.get_constituent, roots)
                    )
                    if something_left:
                        problems = {
                            key: self.head2deps[key]
                            for key in something_left
                        }
                        raise ValueError(
                            &#34;Circular reference detected after trying to fix.&#34;
                            &#34; Missing graph: {}&#34;.format(problems)
                        )

        return roots

    def get_direct_dependents(self, ID):
        &#34;&#34;&#34;
        Get the term IDs of the terms directly dependent on `ID`.

        :param headID:  term ID to get direct dependents of
        :return:        a set of IDs that are direct dependents of `ID`
        &#34;&#34;&#34;
        if ID in self.head2deps:
            return {ID for ID, _ in self.head2deps[ID]}

    def get_direct_parents(self, ID):
        &#34;&#34;&#34;
        Get the term IDs of the terms of which `ID` is a direct dependent.

        :param headID:  term ID to get direct parents of
        :return:        a set of IDs that are direct parents of `ID`
        &#34;&#34;&#34;
        if ID in self.dep2heads:
            return {ID for ID, _ in self.dep2heads[ID]}

    def get_constituent(self, ID):
        &#34;&#34;&#34;
        Get the term IDs of the terms dependent on `ID`.

        Always contains `ID`, even if it is unknown.

        :param headID:  term ID to get constituent of
        :return:        a set of IDs of terms that are dependents of `ID`
        &#34;&#34;&#34;
        try:
            return self._head2constituent[ID]
        except KeyError:
            return self._get_constituent(ID, set())

    def _get_constituent(self, ID, parents):
        &#34;&#34;&#34;
        Calculate the constituent if it is not in the cache

        :param head:      head to find constituent of
        :param parents:   term IDs that are already being calculated, thus
                          should not be recursed into
        :return:          set of term IDs that are in the constituent of `head`
        &#34;&#34;&#34;
        if ID in parents:
            # Prevent loop
            return set()
        elif ID in self._head2constituent:
            # Use cache
            return self._head2constituent[ID]
        # Base case: direct dependents
        deps = {term_id for term_id, _ in self.head2deps.get(ID, [])}
        # Recursive step: call _get_constituent for every direct dependent
        parents.add(ID)
        deps.update(*(
            self._get_constituent(term_id, parents)
            for term_id in deps
        ))
        # Make sure ID itself is in it
        deps.add(ID)
        # Cache
        self._head2constituent[ID] = deps
        return deps

    @staticmethod
    def create_headdep_dict(nafobj):
        &#34;&#34;&#34;
        Create dictionary of head to direct dependents

        :param nafobj:          NAF object from input
        :return:                head2deps
        &#34;&#34;&#34;

        head2deps = {}
        for dep in nafobj.get_dependencies():
            head2deps.setdefault(dep.get_from(), set()).add(
                (dep.get_to(), dep.get_function())
            )
        return head2deps

    @staticmethod
    def filter_direct_self_reference(head2deps):
        &#34;&#34;&#34;
        Filter out any dependents that are the same as their direct parent.

        If this means a head does not have any remaining dependents, the head
        is also removed.
        &#34;&#34;&#34;
        incomplete = {
            head: {
                (dep, info)
                for dep, info in deps
                if dep != head
            }
            for head, deps in head2deps.items()
        }
        # We can&#39;t use `incomplete` for iteration, as its size will change
        for head in head2deps:
            if not incomplete[head]:
                del incomplete[head]
        return incomplete

    @staticmethod
    def filter_headdep_dict(head2deps, term_filter):
        &#34;&#34;&#34;
        Only keep terms where `term_filter(term)` evaluates True.

        If a term is removed, the link (or function) information is handled as
        follows:

            from  --parent info--&gt;  removed  --child info--&gt;  to

        becomes

            from  --child info--&gt;  to

        !! NB !! If a circular reference exists in one of the &#34;trees&#34;, this
                 will stay in, even if some (or all but one) of the terms in
                 the circular reference are filtered out.

        :param head2deps:       {head: {(dep, function), ...}}
        :param term_filter:     filter for terms
        &#34;&#34;&#34;
        dep2headIDs = {}
        for headID, deps in head2deps.items():
            for toID, _ in deps:
                dep2headIDs.setdefault(toID, []).append(headID)
        logger.debug(&#34;dep2headIDs: {}&#34;.format(dep2headIDs))
        filtered = {}
        for headID, deps in head2deps.items():
            # I don&#39;t have to do something with the deps that are filtered out,
            # because if they are leaves they can be left out and if they
            # aren&#39;t leaves they will also appear as headID and handled there.
            logger.debug(&#34;headID: {}&#34;.format(headID))
            deps = {
                (toID, relation)
                for toID, relation in deps
                if term_filter(toID)
            }
            logger.debug(&#34;deps: {}&#34;.format(deps))
            if term_filter(headID):
                if deps:
                    filtered.setdefault(headID, set()).update(deps)
            elif deps:
                # Delete the head by adding its dependents to the most shallow
                # head that isn&#39;t filtered out.
                stack = dep2headIDs.get(headID, [])
                been_in_stack = set(stack)
                super_heads = []
                while stack:
                    logger.debug(&#34;stack: {}&#34;.format(stack))
                    super_head = stack.pop()
                    if term_filter(super_head):
                        super_heads.append(super_head)
                    else:
                        add_to_stack = [
                            h for h in dep2headIDs.get(super_head, [])
                            if h not in been_in_stack
                        ]
                        been_in_stack.update(add_to_stack)
                        logger.debug(&#34;add_to_stack: {}&#34;.format(add_to_stack))
                        stack.extend(
                            add_to_stack
                        )
                for super_head in super_heads:
                    filtered.setdefault(super_head, set()).update(deps)

        return filtered

    def find_head_in_span(self, span):
        &#39;&#39;&#39;
        Find the first term in the `span` that is the head of a constituent
        that contains the whole `span`.

        If no such term exists, `find_closest_to_head` is used as fallback.

        :param span:    list of term identifiers
        :return:        term identifier of head
        &#39;&#39;&#39;

        head_term = None
        for term in span:
            constituent = self.get_constituent(term)
            if set(span) &lt; constituent:
                if head_term is None:
                    head_term = term
            #    else:
            #        print(&#39;span has more than one head&#39;)
        if head_term is None:
            head_term = self.find_closest_to_head(span)
        return head_term

    def find_closest_to_head(self, span):
        &#34;&#34;&#34;
        Find the term that heads the most terms in `span`.

        If there is a tie, the term occurring first is taken.
        &#34;&#34;&#34;
        if len(span) == 1:
            return span[0]

        head_term_candidates = defaultdict(list)

        for tid in span:
            if tid in self.head2deps:
                count = 0
                for deprel in self.head2deps:
                    if deprel[0] in span:
                        count += 1
                head_term_candidates[count].append(tid)

        if len(head_term_candidates) &gt; 0:
            max_deps = sorted(head_term_candidates.keys())[-1]
            best_candidates = head_term_candidates.get(max_deps)
            if len(best_candidates) &gt; 0:
                return best_candidates[0]

        return span[0]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees"><code class="flex name class">
<span>class <span class="ident">ConstituencyTrees</span></span>
<span>(</span><span>head2deps)</span>
</code></dt>
<dd>
<section class="desc"><p>A (bit of a messy) collection of several constituency trees,
together with some convenience functions.</p>
<p>Because NAF-files don't specify what edges are part of which tree,
this class doesn't know either.</p>
<p>This class can't handle it if you change <code>head2deps</code> and/or <code>dep2heads</code>
after initialisation.</p>
<p>!! NB !! Alpino does <strong>not</strong> output strict trees. This means we cannot even
assume we're working with a graph that is a set of disjoint trees,
but have to accept the fact we have to be able to handle every
kind of graph.</p>
<p>Initialise <a title="multisieve_coreference.constituency_trees.ConstituencyTrees" href="#multisieve_coreference.constituency_trees.ConstituencyTrees"><code>ConstituencyTrees</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L8-L379" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ConstituencyTrees:
    &#34;&#34;&#34;
    A (bit of a messy) collection of several constituency trees,
    together with some convenience functions.

    Because NAF-files don&#39;t specify what edges are part of which tree,
    this class doesn&#39;t know either.

    This class can&#39;t handle it if you change `head2deps` and/or `dep2heads`
    after initialisation.

    !! NB !! Alpino does **not** output strict trees. This means we cannot even
             assume we&#39;re working with a graph that is a set of disjoint trees,
             but have to accept the fact we have to be able to handle every
             kind of graph.
    &#34;&#34;&#34;

    def __init__(self, head2deps):
        &#34;&#34;&#34;
        Initialise `ConstituencyTrees`
        &#34;&#34;&#34;
        self.head2deps = head2deps

        # Create the reverse too
        self.dep2heads = self.reverse_headdep_dict(head2deps)

        logger.debug(&#34;head2deps: {}&#34;.format(self.head2deps))
        logger.debug(&#34;dep2heads: {}&#34;.format(self.dep2heads))
        self._head2constituent = {}

    def __repr__(self):
        return self.__class__.__name__ + &#39;({!r})&#39;.format(self.head2deps)

    def __eq__(self, other):
        if isinstance(other, type(self)):
            return self.head2deps == other.head2deps
        return NotImplemented

    @classmethod
    def from_naf(cls, nafobj, term_filter=None,
                 filter_direct_self_reference=False):
        &#34;&#34;&#34;
        Initialise this ConstituencyTrees from a NAF object

        Only keep terms where `term_filter(naf, term)` evaluates True.


        :param nafobj:          NAF object from input
        :type  nafobj:          KafNafParser

        :param term_filter:     filter for terms
        :type  term_filter:     Callable[[KafNafParser, str], bool]

        :param filter_direct_self_reference:
            whether to call `self.filter_direct_self_reference` on the result
        &#34;&#34;&#34;
        if term_filter is None:
            def term_filter(naf, t):
                return True

        filtered = cls.filter_headdep_dict(
            cls.create_headdep_dict(nafobj),
            lambda t: term_filter(nafobj, t)
        )
        if filter_direct_self_reference:
            filtered = cls.filter_direct_self_reference(filtered)
        return cls(filtered)

    @staticmethod
    def reverse_headdep_dict(head2deps):
        &#34;&#34;&#34;
        Create dep2heads from head2deps (or visa versa?)
        &#34;&#34;&#34;
        dep2heads = {}
        for headID, deps in head2deps.items():
            for toID, relation in deps:
                dep2heads.setdefault(toID, set()).add((headID, relation))
        return dep2heads

    def get_roots(self, ignore_non_trees=False, try_fixing=False):
        &#34;&#34;&#34;
        Get the roots of this collection of &#34;trees&#34;.

        The roots are all heads that aren&#39;t a dependent.

        Because of circular references, this could be non-existent for some of
        the &#34;trees&#34;. In those cases an error will be raised, except if
        `ignore_non_trees` is falsey: then the check is skipped entirely.

        if `try_fixing` is truthy, an ugly hack will try to find the &#34;real&#34;
        roots by finding things that point using &#39;-- / --&#39;: the relation Alpino
        uses to point to punctuation.
        &#34;&#34;&#34;
        roots = set(self.head2deps) - set(self.dep2heads)

        # Check for missing roots
        # If none are missing, removing all heads that are dependent of it
        # (including themselves) should leave nothing.
        if not ignore_non_trees or try_fixing:
            something_left = set(self.head2deps).difference(
                *map(self.get_constituent, roots)
            )
            if something_left:
                problems = {key: self.head2deps[key] for key in something_left}
                if not try_fixing:  # This now implies `not ignore_non_trees`
                    raise ValueError(
                        &#34;Circular reference detected.&#34;
                        &#34; Missing graph: {}&#34;.format(problems)
                    )

                # Try finding roots by finding the things that point using
                # &#39;-- / --&#39;
                punct_rel = &#39;-- / --&#39;
                additional_roots = {
                    tID
                    for tID in something_left
                    if punct_rel in map(lambda p: p[1], self.head2deps[tID])
                }

                # Verify we don&#39;t have too many
                for r in additional_roots:
                    # If some additional root dominates some other additional
                    # root, this is a problem, as every connected graph can
                    # have at most one root.
                    dominated = self.get_constituent(r) &amp; additional_roots
                    dominated.remove(r)  # we know `r` must be in there
                    if dominated:
                        raise ValueError(
                            &#34;Found too many additional roots.&#34;
                            &#34; {} dominates {} in {}&#34;.format(
                                r,
                                dominated,
                                problems
                            )
                        )

                roots |= additional_roots

                # Verify we have everything
                if not ignore_non_trees:
                    something_left = set(self.head2deps).difference(
                        *map(self.get_constituent, roots)
                    )
                    if something_left:
                        problems = {
                            key: self.head2deps[key]
                            for key in something_left
                        }
                        raise ValueError(
                            &#34;Circular reference detected after trying to fix.&#34;
                            &#34; Missing graph: {}&#34;.format(problems)
                        )

        return roots

    def get_direct_dependents(self, ID):
        &#34;&#34;&#34;
        Get the term IDs of the terms directly dependent on `ID`.

        :param headID:  term ID to get direct dependents of
        :return:        a set of IDs that are direct dependents of `ID`
        &#34;&#34;&#34;
        if ID in self.head2deps:
            return {ID for ID, _ in self.head2deps[ID]}

    def get_direct_parents(self, ID):
        &#34;&#34;&#34;
        Get the term IDs of the terms of which `ID` is a direct dependent.

        :param headID:  term ID to get direct parents of
        :return:        a set of IDs that are direct parents of `ID`
        &#34;&#34;&#34;
        if ID in self.dep2heads:
            return {ID for ID, _ in self.dep2heads[ID]}

    def get_constituent(self, ID):
        &#34;&#34;&#34;
        Get the term IDs of the terms dependent on `ID`.

        Always contains `ID`, even if it is unknown.

        :param headID:  term ID to get constituent of
        :return:        a set of IDs of terms that are dependents of `ID`
        &#34;&#34;&#34;
        try:
            return self._head2constituent[ID]
        except KeyError:
            return self._get_constituent(ID, set())

    def _get_constituent(self, ID, parents):
        &#34;&#34;&#34;
        Calculate the constituent if it is not in the cache

        :param head:      head to find constituent of
        :param parents:   term IDs that are already being calculated, thus
                          should not be recursed into
        :return:          set of term IDs that are in the constituent of `head`
        &#34;&#34;&#34;
        if ID in parents:
            # Prevent loop
            return set()
        elif ID in self._head2constituent:
            # Use cache
            return self._head2constituent[ID]
        # Base case: direct dependents
        deps = {term_id for term_id, _ in self.head2deps.get(ID, [])}
        # Recursive step: call _get_constituent for every direct dependent
        parents.add(ID)
        deps.update(*(
            self._get_constituent(term_id, parents)
            for term_id in deps
        ))
        # Make sure ID itself is in it
        deps.add(ID)
        # Cache
        self._head2constituent[ID] = deps
        return deps

    @staticmethod
    def create_headdep_dict(nafobj):
        &#34;&#34;&#34;
        Create dictionary of head to direct dependents

        :param nafobj:          NAF object from input
        :return:                head2deps
        &#34;&#34;&#34;

        head2deps = {}
        for dep in nafobj.get_dependencies():
            head2deps.setdefault(dep.get_from(), set()).add(
                (dep.get_to(), dep.get_function())
            )
        return head2deps

    @staticmethod
    def filter_direct_self_reference(head2deps):
        &#34;&#34;&#34;
        Filter out any dependents that are the same as their direct parent.

        If this means a head does not have any remaining dependents, the head
        is also removed.
        &#34;&#34;&#34;
        incomplete = {
            head: {
                (dep, info)
                for dep, info in deps
                if dep != head
            }
            for head, deps in head2deps.items()
        }
        # We can&#39;t use `incomplete` for iteration, as its size will change
        for head in head2deps:
            if not incomplete[head]:
                del incomplete[head]
        return incomplete

    @staticmethod
    def filter_headdep_dict(head2deps, term_filter):
        &#34;&#34;&#34;
        Only keep terms where `term_filter(term)` evaluates True.

        If a term is removed, the link (or function) information is handled as
        follows:

            from  --parent info--&gt;  removed  --child info--&gt;  to

        becomes

            from  --child info--&gt;  to

        !! NB !! If a circular reference exists in one of the &#34;trees&#34;, this
                 will stay in, even if some (or all but one) of the terms in
                 the circular reference are filtered out.

        :param head2deps:       {head: {(dep, function), ...}}
        :param term_filter:     filter for terms
        &#34;&#34;&#34;
        dep2headIDs = {}
        for headID, deps in head2deps.items():
            for toID, _ in deps:
                dep2headIDs.setdefault(toID, []).append(headID)
        logger.debug(&#34;dep2headIDs: {}&#34;.format(dep2headIDs))
        filtered = {}
        for headID, deps in head2deps.items():
            # I don&#39;t have to do something with the deps that are filtered out,
            # because if they are leaves they can be left out and if they
            # aren&#39;t leaves they will also appear as headID and handled there.
            logger.debug(&#34;headID: {}&#34;.format(headID))
            deps = {
                (toID, relation)
                for toID, relation in deps
                if term_filter(toID)
            }
            logger.debug(&#34;deps: {}&#34;.format(deps))
            if term_filter(headID):
                if deps:
                    filtered.setdefault(headID, set()).update(deps)
            elif deps:
                # Delete the head by adding its dependents to the most shallow
                # head that isn&#39;t filtered out.
                stack = dep2headIDs.get(headID, [])
                been_in_stack = set(stack)
                super_heads = []
                while stack:
                    logger.debug(&#34;stack: {}&#34;.format(stack))
                    super_head = stack.pop()
                    if term_filter(super_head):
                        super_heads.append(super_head)
                    else:
                        add_to_stack = [
                            h for h in dep2headIDs.get(super_head, [])
                            if h not in been_in_stack
                        ]
                        been_in_stack.update(add_to_stack)
                        logger.debug(&#34;add_to_stack: {}&#34;.format(add_to_stack))
                        stack.extend(
                            add_to_stack
                        )
                for super_head in super_heads:
                    filtered.setdefault(super_head, set()).update(deps)

        return filtered

    def find_head_in_span(self, span):
        &#39;&#39;&#39;
        Find the first term in the `span` that is the head of a constituent
        that contains the whole `span`.

        If no such term exists, `find_closest_to_head` is used as fallback.

        :param span:    list of term identifiers
        :return:        term identifier of head
        &#39;&#39;&#39;

        head_term = None
        for term in span:
            constituent = self.get_constituent(term)
            if set(span) &lt; constituent:
                if head_term is None:
                    head_term = term
            #    else:
            #        print(&#39;span has more than one head&#39;)
        if head_term is None:
            head_term = self.find_closest_to_head(span)
        return head_term

    def find_closest_to_head(self, span):
        &#34;&#34;&#34;
        Find the term that heads the most terms in `span`.

        If there is a tie, the term occurring first is taken.
        &#34;&#34;&#34;
        if len(span) == 1:
            return span[0]

        head_term_candidates = defaultdict(list)

        for tid in span:
            if tid in self.head2deps:
                count = 0
                for deprel in self.head2deps:
                    if deprel[0] in span:
                        count += 1
                head_term_candidates[count].append(tid)

        if len(head_term_candidates) &gt; 0:
            max_deps = sorted(head_term_candidates.keys())[-1]
            best_candidates = head_term_candidates.get(max_deps)
            if len(best_candidates) &gt; 0:
                return best_candidates[0]

        return span[0]</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.create_headdep_dict"><code class="name flex">
<span>def <span class="ident">create_headdep_dict</span></span>(<span>nafobj)</span>
</code></dt>
<dd>
<section class="desc"><p>Create dictionary of head to direct dependents</p>
<p>:param nafobj:
NAF object from input
:return:
head2deps</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L226-L240" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def create_headdep_dict(nafobj):
    &#34;&#34;&#34;
    Create dictionary of head to direct dependents

    :param nafobj:          NAF object from input
    :return:                head2deps
    &#34;&#34;&#34;

    head2deps = {}
    for dep in nafobj.get_dependencies():
        head2deps.setdefault(dep.get_from(), set()).add(
            (dep.get_to(), dep.get_function())
        )
    return head2deps</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.filter_direct_self_reference"><code class="name flex">
<span>def <span class="ident">filter_direct_self_reference</span></span>(<span>head2deps)</span>
</code></dt>
<dd>
<section class="desc"><p>Filter out any dependents that are the same as their direct parent.</p>
<p>If this means a head does not have any remaining dependents, the head
is also removed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L242-L262" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def filter_direct_self_reference(head2deps):
    &#34;&#34;&#34;
    Filter out any dependents that are the same as their direct parent.

    If this means a head does not have any remaining dependents, the head
    is also removed.
    &#34;&#34;&#34;
    incomplete = {
        head: {
            (dep, info)
            for dep, info in deps
            if dep != head
        }
        for head, deps in head2deps.items()
    }
    # We can&#39;t use `incomplete` for iteration, as its size will change
    for head in head2deps:
        if not incomplete[head]:
            del incomplete[head]
    return incomplete</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.filter_headdep_dict"><code class="name flex">
<span>def <span class="ident">filter_headdep_dict</span></span>(<span>head2deps, term_filter)</span>
</code></dt>
<dd>
<section class="desc"><p>Only keep terms where <code>term_filter(term)</code> evaluates True.</p>
<p>If a term is removed, the link (or function) information is handled as
follows:</p>
<pre><code>from  --parent info--&gt;  removed  --child info--&gt;  to
</code></pre>
<p>becomes</p>
<pre><code>from  --child info--&gt;  to
</code></pre>
<p>!! NB !! If a circular reference exists in one of the "trees", this
will stay in, even if some (or all but one) of the terms in
the circular reference are filtered out.</p>
<p>:param head2deps:
{head: {(dep, function), &hellip;}}
:param term_filter:
filter for terms</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L264-L329" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def filter_headdep_dict(head2deps, term_filter):
    &#34;&#34;&#34;
    Only keep terms where `term_filter(term)` evaluates True.

    If a term is removed, the link (or function) information is handled as
    follows:

        from  --parent info--&gt;  removed  --child info--&gt;  to

    becomes

        from  --child info--&gt;  to

    !! NB !! If a circular reference exists in one of the &#34;trees&#34;, this
             will stay in, even if some (or all but one) of the terms in
             the circular reference are filtered out.

    :param head2deps:       {head: {(dep, function), ...}}
    :param term_filter:     filter for terms
    &#34;&#34;&#34;
    dep2headIDs = {}
    for headID, deps in head2deps.items():
        for toID, _ in deps:
            dep2headIDs.setdefault(toID, []).append(headID)
    logger.debug(&#34;dep2headIDs: {}&#34;.format(dep2headIDs))
    filtered = {}
    for headID, deps in head2deps.items():
        # I don&#39;t have to do something with the deps that are filtered out,
        # because if they are leaves they can be left out and if they
        # aren&#39;t leaves they will also appear as headID and handled there.
        logger.debug(&#34;headID: {}&#34;.format(headID))
        deps = {
            (toID, relation)
            for toID, relation in deps
            if term_filter(toID)
        }
        logger.debug(&#34;deps: {}&#34;.format(deps))
        if term_filter(headID):
            if deps:
                filtered.setdefault(headID, set()).update(deps)
        elif deps:
            # Delete the head by adding its dependents to the most shallow
            # head that isn&#39;t filtered out.
            stack = dep2headIDs.get(headID, [])
            been_in_stack = set(stack)
            super_heads = []
            while stack:
                logger.debug(&#34;stack: {}&#34;.format(stack))
                super_head = stack.pop()
                if term_filter(super_head):
                    super_heads.append(super_head)
                else:
                    add_to_stack = [
                        h for h in dep2headIDs.get(super_head, [])
                        if h not in been_in_stack
                    ]
                    been_in_stack.update(add_to_stack)
                    logger.debug(&#34;add_to_stack: {}&#34;.format(add_to_stack))
                    stack.extend(
                        add_to_stack
                    )
            for super_head in super_heads:
                filtered.setdefault(super_head, set()).update(deps)

    return filtered</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.from_naf"><code class="name flex">
<span>def <span class="ident">from_naf</span></span>(<span>nafobj, term_filter=None, filter_direct_self_reference=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialise this ConstituencyTrees from a NAF object</p>
<p>Only keep terms where <code>term_filter(naf, term)</code> evaluates True.</p>
<p>:param nafobj:
NAF object from input
:type
nafobj:
KafNafParser</p>
<p>:param term_filter:
filter for terms
:type
term_filter:
Callable[[KafNafParser, str], bool]</p>
<p>:param filter_direct_self_reference:
whether to call <code>self.filter_direct_self_reference</code> on the result</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L46-L74" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def from_naf(cls, nafobj, term_filter=None,
             filter_direct_self_reference=False):
    &#34;&#34;&#34;
    Initialise this ConstituencyTrees from a NAF object

    Only keep terms where `term_filter(naf, term)` evaluates True.


    :param nafobj:          NAF object from input
    :type  nafobj:          KafNafParser

    :param term_filter:     filter for terms
    :type  term_filter:     Callable[[KafNafParser, str], bool]

    :param filter_direct_self_reference:
        whether to call `self.filter_direct_self_reference` on the result
    &#34;&#34;&#34;
    if term_filter is None:
        def term_filter(naf, t):
            return True

    filtered = cls.filter_headdep_dict(
        cls.create_headdep_dict(nafobj),
        lambda t: term_filter(nafobj, t)
    )
    if filter_direct_self_reference:
        filtered = cls.filter_direct_self_reference(filtered)
    return cls(filtered)</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.reverse_headdep_dict"><code class="name flex">
<span>def <span class="ident">reverse_headdep_dict</span></span>(<span>head2deps)</span>
</code></dt>
<dd>
<section class="desc"><p>Create dep2heads from head2deps (or visa versa?)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L76-L85" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def reverse_headdep_dict(head2deps):
    &#34;&#34;&#34;
    Create dep2heads from head2deps (or visa versa?)
    &#34;&#34;&#34;
    dep2heads = {}
    for headID, deps in head2deps.items():
        for toID, relation in deps:
            dep2heads.setdefault(toID, set()).add((headID, relation))
    return dep2heads</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.find_closest_to_head"><code class="name flex">
<span>def <span class="ident">find_closest_to_head</span></span>(<span>self, span)</span>
</code></dt>
<dd>
<section class="desc"><p>Find the term that heads the most terms in <code>span</code>.</p>
<p>If there is a tie, the term occurring first is taken.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L354-L379" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def find_closest_to_head(self, span):
    &#34;&#34;&#34;
    Find the term that heads the most terms in `span`.

    If there is a tie, the term occurring first is taken.
    &#34;&#34;&#34;
    if len(span) == 1:
        return span[0]

    head_term_candidates = defaultdict(list)

    for tid in span:
        if tid in self.head2deps:
            count = 0
            for deprel in self.head2deps:
                if deprel[0] in span:
                    count += 1
            head_term_candidates[count].append(tid)

    if len(head_term_candidates) &gt; 0:
        max_deps = sorted(head_term_candidates.keys())[-1]
        best_candidates = head_term_candidates.get(max_deps)
        if len(best_candidates) &gt; 0:
            return best_candidates[0]

    return span[0]</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.find_head_in_span"><code class="name flex">
<span>def <span class="ident">find_head_in_span</span></span>(<span>self, span)</span>
</code></dt>
<dd>
<section class="desc"><p>Find the first term in the <code>span</code> that is the head of a constituent
that contains the whole <code>span</code>.</p>
<p>If no such term exists, <code>find_closest_to_head</code> is used as fallback.</p>
<p>:param span:
list of term identifiers
:return:
term identifier of head</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L331-L352" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def find_head_in_span(self, span):
    &#39;&#39;&#39;
    Find the first term in the `span` that is the head of a constituent
    that contains the whole `span`.

    If no such term exists, `find_closest_to_head` is used as fallback.

    :param span:    list of term identifiers
    :return:        term identifier of head
    &#39;&#39;&#39;

    head_term = None
    for term in span:
        constituent = self.get_constituent(term)
        if set(span) &lt; constituent:
            if head_term is None:
                head_term = term
        #    else:
        #        print(&#39;span has more than one head&#39;)
    if head_term is None:
        head_term = self.find_closest_to_head(span)
    return head_term</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.get_constituent"><code class="name flex">
<span>def <span class="ident">get_constituent</span></span>(<span>self, ID)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the term IDs of the terms dependent on <code>ID</code>.</p>
<p>Always contains <code>ID</code>, even if it is unknown.</p>
<p>:param headID:
term ID to get constituent of
:return:
a set of IDs of terms that are dependents of <code>ID</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L183-L195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_constituent(self, ID):
    &#34;&#34;&#34;
    Get the term IDs of the terms dependent on `ID`.

    Always contains `ID`, even if it is unknown.

    :param headID:  term ID to get constituent of
    :return:        a set of IDs of terms that are dependents of `ID`
    &#34;&#34;&#34;
    try:
        return self._head2constituent[ID]
    except KeyError:
        return self._get_constituent(ID, set())</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.get_direct_dependents"><code class="name flex">
<span>def <span class="ident">get_direct_dependents</span></span>(<span>self, ID)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the term IDs of the terms directly dependent on <code>ID</code>.</p>
<p>:param headID:
term ID to get direct dependents of
:return:
a set of IDs that are direct dependents of <code>ID</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L163-L171" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_direct_dependents(self, ID):
    &#34;&#34;&#34;
    Get the term IDs of the terms directly dependent on `ID`.

    :param headID:  term ID to get direct dependents of
    :return:        a set of IDs that are direct dependents of `ID`
    &#34;&#34;&#34;
    if ID in self.head2deps:
        return {ID for ID, _ in self.head2deps[ID]}</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.get_direct_parents"><code class="name flex">
<span>def <span class="ident">get_direct_parents</span></span>(<span>self, ID)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the term IDs of the terms of which <code>ID</code> is a direct dependent.</p>
<p>:param headID:
term ID to get direct parents of
:return:
a set of IDs that are direct parents of <code>ID</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L173-L181" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_direct_parents(self, ID):
    &#34;&#34;&#34;
    Get the term IDs of the terms of which `ID` is a direct dependent.

    :param headID:  term ID to get direct parents of
    :return:        a set of IDs that are direct parents of `ID`
    &#34;&#34;&#34;
    if ID in self.dep2heads:
        return {ID for ID, _ in self.dep2heads[ID]}</code></pre>
</details>
</dd>
<dt id="multisieve_coreference.constituency_trees.ConstituencyTrees.get_roots"><code class="name flex">
<span>def <span class="ident">get_roots</span></span>(<span>self, ignore_non_trees=False, try_fixing=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the roots of this collection of "trees".</p>
<p>The roots are all heads that aren't a dependent.</p>
<p>Because of circular references, this could be non-existent for some of
the "trees". In those cases an error will be raised, except if
<code>ignore_non_trees</code> is falsey: then the check is skipped entirely.</p>
<p>if <code>try_fixing</code> is truthy, an ugly hack will try to find the "real"
roots by finding things that point using '&ndash; / &ndash;': the relation Alpino
uses to point to punctuation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/MPvHarmelen/coref_draft/blob/fcb5535444fd8ef6a0f9f27c2bcd7e1078a65ace/multisieve_coreference/constituency_trees.py#L87-L161" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_roots(self, ignore_non_trees=False, try_fixing=False):
    &#34;&#34;&#34;
    Get the roots of this collection of &#34;trees&#34;.

    The roots are all heads that aren&#39;t a dependent.

    Because of circular references, this could be non-existent for some of
    the &#34;trees&#34;. In those cases an error will be raised, except if
    `ignore_non_trees` is falsey: then the check is skipped entirely.

    if `try_fixing` is truthy, an ugly hack will try to find the &#34;real&#34;
    roots by finding things that point using &#39;-- / --&#39;: the relation Alpino
    uses to point to punctuation.
    &#34;&#34;&#34;
    roots = set(self.head2deps) - set(self.dep2heads)

    # Check for missing roots
    # If none are missing, removing all heads that are dependent of it
    # (including themselves) should leave nothing.
    if not ignore_non_trees or try_fixing:
        something_left = set(self.head2deps).difference(
            *map(self.get_constituent, roots)
        )
        if something_left:
            problems = {key: self.head2deps[key] for key in something_left}
            if not try_fixing:  # This now implies `not ignore_non_trees`
                raise ValueError(
                    &#34;Circular reference detected.&#34;
                    &#34; Missing graph: {}&#34;.format(problems)
                )

            # Try finding roots by finding the things that point using
            # &#39;-- / --&#39;
            punct_rel = &#39;-- / --&#39;
            additional_roots = {
                tID
                for tID in something_left
                if punct_rel in map(lambda p: p[1], self.head2deps[tID])
            }

            # Verify we don&#39;t have too many
            for r in additional_roots:
                # If some additional root dominates some other additional
                # root, this is a problem, as every connected graph can
                # have at most one root.
                dominated = self.get_constituent(r) &amp; additional_roots
                dominated.remove(r)  # we know `r` must be in there
                if dominated:
                    raise ValueError(
                        &#34;Found too many additional roots.&#34;
                        &#34; {} dominates {} in {}&#34;.format(
                            r,
                            dominated,
                            problems
                        )
                    )

            roots |= additional_roots

            # Verify we have everything
            if not ignore_non_trees:
                something_left = set(self.head2deps).difference(
                    *map(self.get_constituent, roots)
                )
                if something_left:
                    problems = {
                        key: self.head2deps[key]
                        for key in something_left
                    }
                    raise ValueError(
                        &#34;Circular reference detected after trying to fix.&#34;
                        &#34; Missing graph: {}&#34;.format(problems)
                    )

    return roots</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multisieve_coreference" href="index.html">multisieve_coreference</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees" href="#multisieve_coreference.constituency_trees.ConstituencyTrees">ConstituencyTrees</a></code></h4>
<ul class="">
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.create_headdep_dict" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.create_headdep_dict">create_headdep_dict</a></code></li>
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.filter_direct_self_reference" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.filter_direct_self_reference">filter_direct_self_reference</a></code></li>
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.filter_headdep_dict" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.filter_headdep_dict">filter_headdep_dict</a></code></li>
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.find_closest_to_head" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.find_closest_to_head">find_closest_to_head</a></code></li>
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.find_head_in_span" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.find_head_in_span">find_head_in_span</a></code></li>
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.from_naf" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.from_naf">from_naf</a></code></li>
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.get_constituent" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.get_constituent">get_constituent</a></code></li>
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.get_direct_dependents" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.get_direct_dependents">get_direct_dependents</a></code></li>
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.get_direct_parents" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.get_direct_parents">get_direct_parents</a></code></li>
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.get_roots" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.get_roots">get_roots</a></code></li>
<li><code><a title="multisieve_coreference.constituency_trees.ConstituencyTrees.reverse_headdep_dict" href="#multisieve_coreference.constituency_trees.ConstituencyTrees.reverse_headdep_dict">reverse_headdep_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5.dev4+g1709915.d20200207</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>